<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>exam-20110316/Problem2.hs</title>
</head>
<body>
<pre><font color=Blue>{-# LANGUAGE GeneralizedNewtypeDeriving #-}</font>
<u><font color="#804000">module</font></u> <font color=Green>Problem2</font> <u><font color="#804000">where</font></u>
<u><font color="#804000">import</font></u> <font color=Green>Control</font><font color="#800080">.</font><font color=Green>Monad</font> <font color="#808080">(</font>when<font color="#808080">)</font>
<u><font color="#804000">import</font></u> <font color=Green>Control</font><font color="#800080">.</font><font color=Green>Concurrent</font><font color="#800080">.</font><font color=Green>STM</font>

<font color=Blue>-- Problem 2a</font>

<font color=Blue>{- See lecture 10:

pseq, par :: a -&gt; b -&gt; b
-- denotational semantics (pseudo-code):
pseq _|_ y = _|_
pseq _    y = y
par thread main = main

-- Operational semantics (informal):
pseq x y: Evaluate first x, and then y

par thread main: Evaluate thread in parallel, and immediately return main
-}</font>


<font color=Blue>-- Problem 2b</font>
<font color=Blue>-- From RWH Ch.28: </font>
<u><font color="#804000">newtype</font></u> <font color=Green>Gold</font> <font color="#808080">=</font> <font color=Green>Gold</font> <font color=Green>Int</font> 
  <u><font color="#804000">deriving</font></u> <font color="#808080">(</font><font color=Green>Eq</font><font color="#808080">,</font> <font color=Green>Ord</font><font color="#808080">,</font> <font color=Green>Show</font><font color="#808080">,</font> <font color=Green>Num</font><font color="#808080">)</font>
<u><font color="#804000">type</font></u> <font color=Green>Balance</font> <font color="#808080">=</font> <font color=Green>TVar</font> <font color=Green>Gold</font>
transfer <font color="#808080">::</font> <font color=Green>Gold</font> <font color="#808080">-&gt;</font> <font color=Green>Balance</font> <font color="#808080">-&gt;</font> <font color=Green>Balance</font> <font color="#808080">-&gt;</font> <font color=Green>IO</font> <font color=Green>()</font>
transfer qty fromBal toBal <font color="#808080">=</font> atomically <font color="#800080">$</font> <u><font color="#804000">do</font></u>
  fromQty <font color="#808080">&lt;-</font> readTVar fromBal
  when <font color="#808080">(</font>qty <font color="#800080">&gt;</font> fromQty<font color="#808080">)</font> <font color="#800080">$</font>
    retry
  writeTVar fromBal <font color="#808080">(</font>fromQty <font color=Blue>-</font> qty<font color="#808080">)</font>
  readTVar toBal <font color="#800080">&gt;&gt;=</font> writeTVar toBal <font color="#800080">.</font> <font color="#808080">(</font>qty <font color="#800080">+</font><font color="#808080">)</font>


<font color=Blue>-- 1c)</font>
<font color=Blue>{- Because of referential transparency (purity) the STM code would
evaluate in exactly the same way if run again before any variable has
changed. In that way some unneccessary work can be avoided.

It will continue (redo) the computation after any change of an
accessed variable (so also if the first balance has been decreased,
even though that would still lead to a new retry).
-}</font>
</pre>
</body>
</html>