\documentclass[a4,11pt]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{graphicx} % for photos
\usepackage{enumerate}
\usepackage{mathpartir}
\usepackage{fullpage}
\usepackage{fancybox}
\usepackage{wrapfig}

%include polycode.fmt
%format m1
%format m2
%format m3
%format k1
%format k2
%format k3

%format x1
%format x2

\newif\ifsol
\soltrue
%\solfalse

\newif\iffrontpage
\frontpagetrue

\lstset{
      basicstyle=\small\ttfamily,
      escapeinside={/+}{+/},
      flexiblecolumns=false,
      basewidth={0.5em,0.45em},
}

\newcommand{\erl}{\lstinline[language=Erlang,morekeywords=fun,backgroundcolor=\color{white},breakatwhitespace=true]}

\newcommand{\java}{\lstinline[language=Java,backgroundcolor=\color{white},breakatwhitespace=true]}



\ifsol
\newcommand{\sol}[1]{\sf #1}
\else
\newcommand{\sol}[1]{}
\fi

\newcommand{\points}[1]{\hfill \textsl{({#1}p)}}

%\input{decs.tex}



\setlength{\itemsep}{0cm}
\setlength{\parsep}{0cm}

\renewcommand{\labelenumii}{\arabic{enumii}}


\begin{document}
\noindent
\textsf{\bfseries Chalmers} $\vert$ \textsc{G\"oteborgs Universitet}
%%%%%%%%%%%%%
\hfill ~\\
%%%%%%%%%%%%%
Alejandro Russo, Computer Science and Engineering \hfill ~\\

\vspace{2 em}
\begin{center}
{\Large {\bf Advanced Functional Programming TDA342/DIT260}}
\\[2ex]
Monday, August 21, 2017, "Maskin"-salar, 14:00 (4hs)
\ifsol
\\[2ex]
(including example solutions to programming problems)
\fi
\\[2ex]
Alejandro Russo, tel. 0729-744-968
\end{center}
\vspace{1 em}

\iffrontpage

\begin{itemize}
\item The maximum amount of points you can score on the exam: 60 points.
The grade for the exam is as follows:

Chalmers:~~\textbf{3}: 24 - 35 points, \textbf{4}: 36 - 47 points,  \textbf{5}: 48 - 60 points. \\
GU:~~Godk\"and 24-47 points, V\"al godk\"and 48-60 points \\ PhD student: 36
points to pass.

\item Results: within 21 days.

\item \textbf{Permitted materials (Hj\"alpmedel):} Dictionary
  (Ordlista/ordbok).

  You may bring up to two pages (on one A4 sheet of paper) of pre-written notes
  -- a ``summary sheet''. These notes may be typed or handwritten. They may be
  from any source. If this summary sheet is brought to the exam it must also be
  handed in with the exam (so make a copy if you want to keep it).

\item \textbf{Notes:}
\begin{itemize}
\item Read through the paper first and plan your time.
\item Answers preferably in English, some assistants might not read Swedish.
\item If a question does not give you all the details you need, you may make
  reasonable assumptions.  Your assumptions must be clearly stated.  If your
  solution only works under certain conditions, state them.
\item
  Start each of the questions on a new page.

\item The exact syntax of Haskell is not so important as long as the graders can
  understand the intended meaning.  If you are unsure just put in an explanation
  of your notation.

\item Hand in the summary sheet (if you brought one) with the exam solutions.

\item As a recommendation, consider spending around 1h 20 minutes per
  exercise. However, this is only a recommendation.

\item To see your exam: \emph{by appointment (send email to Alejandro Russo)}
\end{itemize}

\end{itemize}
%\end{itemize}
\vfill\hfill

\newpage
\fi


%%
%
% Proving
%
%%
\noindent
\textbf{Problem 1:} (\textbf{Phantom types})

A phantom type is a parametrised type whose parameters do not \emph{all} appear
on the right-hand side of |=|.
%
An example of such type is the following.
%
\begin{code}
newtype Const a b = Const a
\end{code}
%
Here |Const| is a phantom type since type parameter |b| does not occur in the
implementation of the type.
%
The idea of having ``phantom'' arguments (like |b|) above is commonly used to
capture some invariant about the data contained by such data type.
%
Let us consider the following example.
%
You are programming a web server and you know that forms accompanying web
requests must be validated before processing them.
%
To implement such invariant, we introduce the following two empty types.
%
\begin{code}
data Unvalidated
data Validated
\end{code}
%
Now, we declare the phantom type
\begin{code}
data FormData a = FormData String
\end{code}
which uses |a| to indicate if the string has been validated.
%
For instance, an string is initially considered as an unvalidated form.
%
\begin{code}
formData :: String -> FormData Unvalidated
\end{code}
%
Then, a validation function takes an \emph{unvalidated} form into
a possibly valid one.
%
\begin{code}
validate :: FormData Unvalidated -> Maybe (FormData Validated)
\end{code}
%
Once the string is validated, it can then be process.
%
\begin{code}
useData :: FormData Validated -> IO ()
\end{code}

\begin{enumerate}

\item[\textbf{a)}] % Example of phamton type
  You got a piece of code which manage different measurements with the following
  interface.
%
\begin{code}
data Measure = Measure Float

measure_m   ::  IO  Measure

measure_km  ::  IO  Measure

add :: Measure -> Measure -> Measure
add (Measure x1) (Measure x2) = Measure (x1 + x2)

\end{code}
%
However, you realize that measurements might be done in meters (|measure_m|), or
(|measure_km|) kilometers.
%
Furthermore, function |add| might add centimeters and kilometers, producing a
measurement which has no sense.
%
Your task is to modify the type signatures of the API above with phantom types
to avoid mixing measurements of different units.
%
Do you need to change the implementation of the function |add|?

\ifsol
\begin{code}
data Kilometer
data Meter

data Measure u = Measure Float

measure_m   ::  IO  (Measure Meter)

measure_km  ::  IO  (Measure Kilometer)

add :: Measure u -> Measure u -> Measure u
add (Measure x1) (Measure x2) = Measure (x1 + x2)
\end{code}
\fi

\points{8}

\item[\textbf{b)}] % Overloading
In the previous item, you realize that function |add| can only add measurements
of the same unit.
%
To make the programming experience more smooth, you need to provide an
overloaded version of |add| so that it can handle arguments of different units.
%
\ifsol
\begin{code}
class Comb a b c where
  add' :: a -> b -> c

instance Comb (Measure Meter) (Measure Kilometer) (Measure  Meter) where
  add' (Measure m) (Measure km) = Measure (m + 1000*km)

instance Comb (Measure Meter) (Measure Kilometer) (Measure Kilometer) where
  add' (Measure m) (Measure km) = Measure (km + m*0.001))

-- More instances that are trivially defined
\end{code}
\fi
\points{4}

\item[\textbf{c)}] % Data promotion

  As introduced the phantom type |FormData a| in \textbf{a)}, it allows type
  variable |a| to by instantiate to an arbitrary type.
%
For instance, it could be instantiated to |Bool| and |Float|
\begin{code}
fb :: FormData Bool
ff :: FormData Float
\end{code}
which has no meaning for the considered scenario.
%
We would like to restrict |a| to be only instantiate to types |Unvalidated|
and |Validated|.
%
Your task is to write a code where the phantom type in \textbf{a)} can only be
instantiated to such types. Which extension of GHC do you need?

\ifsol
\begin{code}
{-# LANGUAGE DataKinds #-}

data IsValid = Unvalidated | Validated
data FormData (a :: IsValid) = FormData String
\end{code}
\fi

\points{8}

\end{enumerate}

\newpage
%%
%
% Proving
%
%%
\noindent
\textbf{Problem 2:} (\textbf{Functors}) As its name implies, a binary tree is a
tree with a two-way branching structure, i.e., a left and a right sub tree. In
Haskell, such trees can be defined as follows.

\begin{code}
data Tree a where
     Leaf  ::  a -> Tree a
     Node  ::  Tree a -> Tree a -> Tree a
\end{code}

\begin{enumerate}

\item[\textbf{a)}] % Tree as a functor
  Show that |Tree a| is a functor. For that, you should \emph{provide} an
  instance for the |Functor| type-class and \emph{prove} that |fmap| for
  \emph{finite trees}, i.e., |fmap :: (a -> b) -> Tree a -> Tree b|, fulfills
  the laws for functors -- see Figure \ref{fig:functor}.

  \begin{figure}[t]
  \shadowbox{
  \begin{mathpar}
  \inferrule[Functor type-class]
  {}
  {|class  Functor c where
           fmap :: (a -> b) -> c a -> c b|
  }
  \and
  \inferrule[Identity]
  {}
  {
  |fmap  id == id
         where id = \x -> x | }
  \and
  \inferrule[Map fusion]
  {}
  {|fmap (f . g) == fmap f . fmap g|}
  \end{mathpar}
  }
  \caption{Functors \label{fig:functor}}
  \end{figure}


   \ifsol
   \begin{code}
   instance Functor Tree where
       fmap  f  (Leaf a)      =  Leaf (f a)
       fmap  f  (Node t1 t2)  =  Node (fmap f t1) (fmap f t2)
   \end{code}
   \fi


  \underline{\textbf{Important}}:
  Assume that |f| and |g| are total, i.e., they do not raise any errors or loop
  indefinitely when applied to an argument. If your proof is by induction,
  you should indicate \emph{induction on what} (e.g., in the length of the
  list). Justify every step in your proof.

  \points{8}

  \ifsol
  \underline{Proofs by induction on the height of the tree}

  \begin{code}
  -- Identity law

  -- Base case
      fmap id (Leaf a)          ==
  --  { by definition fmap.0 }
      Leaf (id a)               ==
  --  { by definition of id }
      Leaf a                    ==
  --  { by definition of id }
      id (Leaf a)

  -- Inductive case
      fmap id (Node l r)            ==
  --  { by definition of fmap.1 }
      Node (fmap id l) (fmap id r)  ==
  --  { by I.H. }
      Node (id l) (id r)            ==
  --  { by definition of id }
      Node l r                      ==
  --  { by definition of id }
      id (Node l r)


  -- Map fusion

  -- Base case
      fmap (f . g) (Leaf a)        ==
  --  { by definition fmap.0 }
      Leaf ((f . g) a)             ==
  --  { by definition of . }
      Leaf (f (g a))               ==
  --  { by definition of fmap.0 }
      fmap f (Leaf (g a))          ==
  --  { by definition of fmap.0 }
      fmap f (fmap g (Leaf a))

  -- Inductive case
      fmap (f . g) (Node l r)                       ==
  --  { by definition of fmap.1 }
      Node (fmap (f . g) l)    (fmap (f . g) r)     ==
  --  { by I.H. }
      Node (fmap f (fmap g l)) (fmap f (fmap g r))  ==
  --  { by definition of fmap.1 }
      fmap f (Node (fmap g l) (fmap g r))           ==
  --  { by definition of fmap.1 }
      fmap f (fmap g (Node l r))
  \end{code}
  \fi

\item [\textbf{b)}] As with lists, it is also useful to ``fold'' over
  trees. Given a tree $t$ with elements $e_1$, $e_2$, $\ldots$, $e_n$ and an
  operator $\oplus$, folding over the tree $t$ with operator $\oplus$
  intuitively means to \emph{intercalate} the operator among the elements of the
  tree, i.e., $e_1 \oplus e_2 \oplus e_3 \oplus \ldots \oplus e_n$. For
  simplicity, we assume that the operator $\oplus$ is always associative.
  We call the function implementing folding over trees |foldT|.

  \begin{code}
  foldT :: (a -> a -> a) -> Tree a -> a
  \end{code}

  By using |foldT|, we can now express a bunch of useful functions on trees.

  \shadowbox{
  \begin{mathpar}
  \inferrule[$P_1$]
  {}
  {|height_tree = foldT (\l r -> max l r + 1) . fmap (const 0)|}
  \and
  \inferrule[$P_2$]
  {}
  {|sum_tree = foldT (+)|}
  \and
  \inferrule[$P_3$]
  {}
  {|leaves = foldT (++) . fmap (\x -> [x])|}
  \end{mathpar}
  }

  Program $P_1$ computes the height of a tree. Program $P_2$ sums
  all the numbers in a tree. Program $P_3$ extracts all the elements of a tree.

  Your task is to implement |foldT|. \points{4}

  \ifsol
  \begin{code}
  foldT :: (a -> a -> a) -> Tree a -> a
  foldT  op  (Leaf a)    =  a
  foldT  op  (Node l r)  =  (foldT op l) `op` (foldT op r)
  \end{code}
  \fi

\item [\textbf{c)}] There is a relation between mapping functions over trees'
  leaves and lists. More specifically, we have the following equation for finite
  and well-defined trees.

  \begin{code}
  map f . leaves == leaves . fmap f
  \end{code}

  It is the same to first extract the leaves and then map the function
  (left-hand side), as it is to map the function first and then extracting the
  leaves (right-hand side).

  Your task is to prove that the equation holds.

  \textbf{You can assume the following
  properties and definition for this exercise and the rest of the exam!}

  \shadowbox{
  \begin{mathpar}
  \inferrule[(.)]
  {}
  {|(f . g) x = f (g x)|}
  \and
  \inferrule[Assoc. (.)]
  {}
  {|(f . g) . z = f . (g . z)|}
  \and
  \inferrule[(id left)]
  {}
  {|id . f = f|}
  \and
  \inferrule[(id right)]
  {}
  {|f . id = f|}
  \and
  \inferrule[(eta)]
  {}
  {|\x -> f x == f|}
  \and
  \inferrule[(cons.0)]
  {}
  {|x:[] = [x]|}
  \and
  \inferrule[(|(++)|.0)]
  {}
  {|[] ++ ys = ys|}
  \and
  \inferrule[(|(++)|.1)]
  {}
  {|(x:xs) ++ ys = x:(xs ++ ys)|}
  \and
  \inferrule[(Assoc. |(++)|)]
  {}
  {|xs ++ (ys ++ zs) == (xs ++ ys) ++ zs|}
  \and
  \inferrule[(|map|.0)]
  {}
  {|map f [] = []|}
  \and
  \inferrule[(|map|.1)]
  {}
  {|map f (x:xs) = f x:map f xs|}
  \end{mathpar}
  }

  You cannot assume any property that relates |(++)|, |map|, and |fmap| -- if
  you need such properties, you should prove them too!  \points{8}

  \ifsol
  \begin{code}
  -- Auxiliary lemma
  map f (xs ++ ys) == map f xs ++ map f ys

  -- Proof by induction on the length of xs

  -- Base case
     map f ([] ++ ys)  ==
  -- (++).0
     map f ys          ==
  -- (++).0
     [] ++ map f ys    ==
  -- map.0
     map f [] ++ map f ys

  -- Inductive case
     map f ((x:xs) ++ ys)          ==
  -- map.1
     f x : map f (xs ++ ys)        ==
  -- I.H.
     f x : (map f xs ++ map f ys)  ==
  -- (++).1
     (f x : map f xs) ++ map f ys  ==
  -- map.1
     map f (x:xs) ++ map f ys
  \end{code}

  \begin{code}
  -- Proof by induction on the height of trees
  map f . leaves == leaves . fmap f

  -- Base case
  map f (leaves (Leaf a))                         ==
  -- Def. leaves
  map f (foldT (++) (fmap (\x -> [x]) (Leaf a)))  ==
  -- Def. fmap on Leaf
  map f (foldT (++) (Leaf [a]))                   ==
  -- Def. foldT
  map f [a]                                       ==
  -- Def (:)
  map f (a:[])                                    ==
  -- Def map.1
  f a : map f []                                  ==
  -- Def. map.0
  f a : []                                        ==
  -- Def (:)
  [f a]                                           ==
  -- Def. leaves
  leaves (Leaf (f a))                             ==
  -- Def. fmap
  leaves (fmap f (Leaf a))

  -- Inductive case
  map f (leaves (Node l r))                       ==
  -- Def. leaves
  map f (foldT (++) (Node l r))                   ==
  -- Def. foldT
  map f ((foldT (++) l) ++ (foldT (++) r))        ==
  -- Auxiliary lemma
  map f (foldT (++) l) ++ map f (foldT (++) r)    ==
  -- Def. leaves
  map f (leaves l) ++ map f (leaves r)            ==
  -- IH
  leaves (fmap f l) ++ leaves (fmap f r)          ==
  -- Def. leaves
  foldT (++) (fmap f l) ++ foldT (++) (fmap f r)  ==
  -- Def. foldT
  foldT (++) (Node (fmap f l) (fmap f r))         ==
  -- Def. leaves
  leaves (Node (fmap f l) (fmap f r))             ==
  -- Def. fmap
  leaves (fmap f (Node l r))
  \end{code}
  \fi

\end{enumerate}

\newpage
\noindent
\textbf{Problem 3:} (\textbf{Miscelaneous})

\begin{enumerate}

% \item[\textbf{a)}] Explain what ``pure'' (referentially transparent) means in a
%   functional programming context and how it relates to equational
%   reasoning.
% %
% \points{5}

\item[\textbf{a)}] Write a function of type |a -> b|, where |a| and |b| are
  polymorphic types.
\points{4}

\ifsol
\begin{code}
f :: a -> b
f a = undefined
\end{code}

\fi
\item[\textbf{b)}] Let us consider the alternative formulation of monads.

  \begin{code}
  return'  ::  a -> m a
  join     ::  m (m a)   -> m a
  fmap     ::  (a -> b)  -> m a -> m b
  \end{code}

  This interface requires |m| to be a functor and introduces an operation called
  |join|.
%
  Furthermore, |return'|, |join|, and |fmap| are required to obey various
  different laws involving return and bind.

  \begin{code}
  m >>= f                ==   join (fmap f m)

  m >>= id               ==   join m

  m >>= (return circ f)  ==   fmap f m
  \end{code}

  Now, let us consider the function |(+)| with the following type signature:

  \begin{code}
  (+) :: Num a => a -> a -> a
  \end{code}

  What is the output of |join (+)|? Hint: remember the reader monad.

  \ifsol
  We need to make match |a -> a -> a| with |m (m a)|. This implies that
  |m == (a ->)|, which is reader monad.
  %
  By the laws, we know that |join mm == mm >>= id|.
  %
  So,
  \begin{code}
  join (+) == (+) >>= id
  -- The definition of bind for the reader monad is:
  f >>= k = \a -> k (f a) a
  -- Therefore,
  (+) >>= id = \a -> id ((+) a) a
  -- Further reducing
  (+) >>= id = \a -> ((+) a) a
  -- Which is the function double
  \a -> a + a
  \end{code}
  \fi
  \points{8}

\item[\textbf{c)}] Give an example of a data type definition which is not a
  functor and explain why is the case.
%
  You should be clear why |fmap| cannot be implemented.

  \ifsol
  \begin{code}

   -- The a is in negative position, so fmap cannot apply the function since
   -- there is no a
   data F a = F (a -> ())
  \end{code}
  \fi

  \points{4}

\item[\textbf{d)}] Define a data type that is a functor and not applicative. %
Define |fmap| and justify why the instance |Applicative| cannot be defined.

  \ifsol
  \begin{code}
    data Pair r a = Pair r a

    instance Functor (Pair r) where
      -- possible

    instance Applicative (Pair r) where
      pure a = -- The pair cannot be built since pure receives an a
               -- but it also needs an r, which does not receive.
  \end{code}
  \fi
 \points{4}
\end{enumerate}






\end{document}

% Local Variables:
% TeX-master: "2016-03.tex"
% TeX-command-default: "Make"
% End:
